#!/usr/bin/env python

import rospy
import actionlib
import cv2
import numpy as np
import logging


import tf
from cv_bridge import CvBridge, CvBridgeError
from sensor_msgs.msg import CompressedImage, Image, LaserScan
from geometry_msgs.msg import Twist, Point, Quaternion, Pose, PoseWithCovariance, TwistWithCovariance
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from actionlib_msgs.msg import GoalStatus
from nav_msgs.msg import Odometry

from nav_msgs.msg import Odometry

# RED
MIN_RED = np.asarray([0, 25, 0])
MAX_RED = np.asarray([10, 255, 255])

# YELLOW
MIN_YELLOW = np.asarray([255, 50, 0])
MAX_YELLOW = np.asarray([255, 255, 255])

# BLUE
MIN_BLUE = np.asarray([120, 50, 0])
MAX_BLUE = np.asarray([143, 255, 255])


COLOR = {'BLUE': (255, 0, 0), 'RED': (0, 0, 255), 'YELLOW': (255, 255, 0)}

COOR = {'BLUE': (2.15, -0.658, 0), 'RED': (2.15, -0.354, 0.00267)}


class Trigger:
    def __init__(self, name):
        self.trigger = False
        self.name = name

    def enable(self):
        self.trigger = True

    def disable(self):
        self.trigger = False

    def status(self):
        return self.trigger


class navigation:
    def __init__(self):
        self.base_move = actionlib.SimpleActionClient(
            'move_base', MoveBaseAction)

        self.base_move.wait_for_server(rospy.Duration(10))

    def move_goal(self, pos, quat):
        goal = MoveBaseGoal()
        goal.target_pose.header.frame_id = 'map'
        goal.target_pose.header.stamp = rospy.Time.now()
        goal.target_pose.pose = Pose(
            Point(pos[0], pos[1], pos[2]), Quaternion(quat[0], quat[1], quat[2], quat[3]))

        self.base_move.send_goal(goal)

        success = self.base_move.wait_for_result(rospy.Duration(60))
        state = self.base_move.get_state()

        print(success, state)


class cv_converter:
    def __init__(self):
        self.image_sub = rospy.Subscriber(
            'camera/image/compressed', CompressedImage, self.callback)
        self.image_pub = rospy.Publisher(
            'camera2/image/compressed', CompressedImage, queue_size=1)
        self.bridge = CvBridge()

        self.circles = 0

    def callback(self, data):
        try:
            cv_image = self.bridge.compressed_imgmsg_to_cv2(data)
        except CvBridgeError as e:
            print(e)

        org_image = cv_image
        cv_image = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)

        circles_red = compute_contours(cv_image, org_image, MIN_RED, MAX_RED)
        circles_blue = compute_contours(
            cv_image, org_image, MIN_BLUE, MAX_BLUE)
        circles_yellow = compute_contours(
            cv_image, org_image, MIN_YELLOW, MAX_YELLOW)

        self.circles = {'RED': circles_red,
                        'BLUE': circles_blue, 'YELLOW': circles_yellow}

        for color in self.circles:
            for point in self.circles[color]:
                cv2.circle(org_image, point[0], 5, COLOR[color], 3)
        try:
            compressed_image = self.bridge.cv2_to_compressed_imgmsg(org_image)
            self.image_pub.publish(compressed_image)
        except CvBridgeError as e:
            print(e)


def compute_contours(image, org_image, range_min, range_max):
    binary_image = cv2.inRange(image, range_min, range_max)

    _, contours, _ = cv2.findContours(
        binary_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    sorted_contours = [cnt for cnt in contours if cv2.contourArea(cnt) > 120]

    circles = []

    for contour in sorted_contours:
        (x, y), r = cv2.minEnclosingCircle(contour)
        circles.append([(int(x), int(y)), int(r)])

    return circles


def callback(data):
    print(np.mean(data.ranges[30:45]))
    # print('{} {}'.format(np.argmin(data.ranges), data.range_min))


def odomcallback(data):
    twist = data.twist
    pose = data.pose

    print(twist.twist)
    print(pose.pose)


if __name__ == "__main__":
    rospy.init_node('robosot_navigation', anonymous=True)
    # cmd_pub = rospy.Publisher('cmd_vel', Twist, queue_size=1)
    # pos_sub = rospy.Subscriber('odom', Odometry, tf_callback)

    # cv_con = cv_converter()
    # navigator = navigation()
    # rospy.sleep(2)

    # rate = rospy.Rate(10)

    odom = rospy.Subscriber(
        'odom', Odometry, queue_size=10, callback=odomcallback)
    # laserscan = rospy.Subscriber('scan', LaserScan, queue_size=10, callback=callback)

    while not rospy.is_shutdown():
        pass

        # while not rospy.is_shutdown():
        #     # print(cv_con.circles)

        #     red = len(cv_con.circles['RED'])
        #     blue = len(cv_con.circles['BLUE'])

        #     if not gen_trigger.status():
        #         if red > 0:
        #             gen_trigger.enable()
        #             stop_trigger.disable()
        #             trig_color = 'RED'
        #         elif blue > 0:
        #             gen_trigger.enable()
        #             stop_trigger.disable()
        #             trig_color = 'BLUE'
        #         else:
        #             trig_color = 'NULL'

        #     if trig_color != 'NULL':
        #         twist = Twist()

        #         if len(cv_con.circles[trig_color]) > 0:
        #             coor, radius = cv_con.circles[trig_color][0]
        #             twist.linear.x = float(0.23)
        #             twist.angular.z = float(160 - coor[0]) * 0.005
        #             print('moving {}'.format(coor))
        #             cmd_pub.publish(twist)
        #         else:
        #             if not stop_trigger.status():
        #                 stop_trigger.enable()
        #                 gen_trigger.disable()
        #                 rospy.sleep(1)

        #                 navigator.move_goal(
        #                     COOR[trig_color], (-0.001, 0.0, -0.016, 1.0))

        #                 twist.linear.x = float(0.1)
        #                 cmd_pub.publish(twist)

        #                 rospy.sleep(2)

        #                 twist.linear.x = float(0.0)
        #                 cmd_pub.publish(twist)

        #                 rospy.sleep(1)

        #                 twist.linear.x = float(-0.1)
        #                 cmd_pub.publish(twist)

        #                 rospy.sleep(1)

        #                 twist.linear.x = float(0.0)
        #                 cmd_pub.publish(twist)

        #                 rospy.sleep(1)

        #                 twist.linear.x = float(0.0)
        #                 twist.angular.z = float(1.0)
        #                 cmd_pub.publish(twist)

        #                 rospy.sleep(3)

        #                 twist.linear.x = float(0.0)
        #                 twist.angular.z = float(0.0)
        #                 cmd_pub.publish(twist)

        #     print(stop_trigger.status())

        #     print('{}: {}'.format(rospy.Time.now().secs, trig_color))

        #     rate.sleep()
